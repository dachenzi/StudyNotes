
# 1、用面向对象实现LinkedList链表
# 单向链表实现append，iternodes方法
# 双向链表实现append、pop、insert、remove、iternodes方法    
    
    
class LinkNode:
    
    def __init__(self, item, next=None):
        self.item = item 
        self.next = next 
        
class LinkedList:
    def __init__(self):
        self.head = None 
        self.tail = None    # append方法需要使用
    
    def append(self,item): # 尾部追加, item就是数据本身
        node = ListNode(item)
        if self.tail is None:  # 空列表
            self.head = node 
            # self.tail = node
        else:
            self.tail.next = node 
            # self.tail = node 
        self.tail = node 
            
    def iternodes(self):
        current = self.head 
        while current:
            yield current
            currnet = current.next
# ---------------------------------------------------------------      
class LinkNode:

    def __init__(self, item, next=None):
        self.item = item
        self.next = next

    def __repr__(self):
        return "{} ==> {} ".format(
            self.item,
            self.next.item if self.next else None
        )

class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None  # append方法需要使用

    def append(self, item):  # 尾部追加, item就是数据本身
        node = LinkNode(item)
        if self.tail is None:  # 空列表
            self.head = node
            # self.tail = node
        else:
            self.tail.next = node
            # self.tail = node
        self.tail = node
        return self  # 链式编程

    def iternodes(self):
        current = self.head
        while current:
            yield current
            current = current.next

daxin = LinkedList()
daxin.append(1).append(2).append(3)

for x in daxin.iternodes():
    print(x)        

## 双向链表
class LinkNode:

    def __init__(self, item, prev=None, next=None):
        self.item = item
        self.next = next
        self.prev = prev

    def __repr__(self):
        return "{} <== {} ==> {} ".format(
            self.item,
            self.next.item if self.next else None,
            self.prev.item if self.prev else None
        )


class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None  # append方法需要使用

    def append(self, item):  # 尾部追加, item就是数据本身
        node = LinkNode(item)
        if self.tail is None:  # 空列表
            self.head = node
            # self.tail = node
        else:
            self.tail.next = node
            node.prev = self.tail  # 指定当前元素的前一个元素
        self.tail = node
        return self  # 链式编程

    def insert(self, index, item):  # 指定所以位置插入
        if index < 0:
            raise IndexError('Not negative Index {}'.format(index))

        # index >= 0
        current = None
        for i, node in enumerate(self.iternodes()):
            if i == index:  # 找到了
                current = node
                break
        else:  # 没找到
            self.append(item)
            return

        # 找到了还没有处理
        node = LinkNode(item)

        # 找到的current
        prev = current.prev

        # node 的
        next = current

        if prev is None:  # 说明索引0 位置插入（i==0,self.head = prev)
            self.head = node
            # node.next = next
            # next.prev = node
        else:
            # node.next = next
            node.prev = prev
            prev.next = node
            # next.prev = node
        node.next = next
        next.prev = node

    def pop(self):  # 尾部弹出
        if self.tail is None:
            raise Exception('Empty')

        node = self.tail
        item = node.item
        prev = node.prev
        # next = node.next

        # 至少有1个
        if self.head == self.tail:  # self.tail.prev is None
            self.head = None
            self.tail = None
        else:
            prev.next = None
            self.tail = prev
        return item

    def remove(self, index):  # 指定索引删除
        if index < 0:
            raise IndexError('Not negatice index {}'.format(index))
        if self.tail is None:
            raise Exception('Empty')

        # index >= 0
        current = None
        for i, node in enumerate(self.iternodes()):
            if i == index:  # 找到了
                current = node
                break
        else:  # 没找到
            raise IndexError('Not negatice index {}'.format(index))  # 程序终止

        # 找到了
        prev = current.prev
        next = current.next

        if prev is None and next is None:  # 只有1个元素
            self.head = None
            self.tail = None
        elif prev is None:  # 删除头部
            next.prev = None
            self.head = next
        elif next is None:  # 删除尾部
            prev.next = None
            self.tail = prev
        else:  # 删除中间的位置
            prev.next = next
            next.prev = prev
        del current

    def iternodes(self, reverse=False):
        current = self.head if not reverse else self.tail
        while current:
            yield current
            current = current.next if not reverse else current.prev


daxin = LinkedList()
daxin.append(1).append(2).append(3)

for x in daxin.iternodes():
    print(x)
