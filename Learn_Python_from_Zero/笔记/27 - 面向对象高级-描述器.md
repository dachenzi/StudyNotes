# 1 描述器
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般来说，一个描述器是一个有'\_\_`绑定行为`\_\_'的对象属性(object attribute)，它的访问控制被描述器协议方法重写。这些方法是 \_\_get\_\_(), \_\_set\_\_(), 和 \_\_delete\_\_() 。
> 有这些方法的对象叫做描述器。  

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认对属性的访问控制是从对象的字典里面(\_\_dict\_\_)中获取、设置和删除它。举例来说, 比如 a.x 的查找顺序是, a.\_\_dict\_\_['x'] , 然后 type(a).\_\_dict\_\_['x'] , 然后找 type(a) 的父类(不包括元类(metaclass)). 如果查找到的值是一个描述器, Python就会调用描述器的方法来重写默认的控制行为。这个重写发生在这个查找环节的哪里取决于定义了哪个描述器方法。注意, 只有在新式类中时描述器才会起作用。(新式类是继承自 type 或者 object 的类)。
# 2 描述器协议
描述器主要涉及三个方法：
1. descr.\_\_get\_\_(self, obj, type=None) --> value
2. descr.\_\_set\_\_(self, obj, value) --> None
3. descr.\_\_delete\_\_(self, obj) --> None 

一个对象具有其中任一个方法就会成为描述器，从而在被当作对象属性时重写默认的查找、设置和删除行为。
## 2.1 非数据描述器
在类中仅仅定义了__get__方法的描述器被称为非数据描述器。
```python
class A:
    def __init__(self):
        self.a1 = 'a1'
        print('A.init')

    def __get__(self, instance, owner):
        pass
        # return self
class B:
    x = A()

    def __init__(self):
        print('B.init')

print('-' * 20)
b = B()
print(b.x.a1)

# Traceback (most recent call last):
# A.init
# --------------------
# B.init
#   File "E:/Python - base - code/ClassDesc.py", line 20, in <module>
#     print(b.x.a1)
# AttributeError: 'NoneType' object has no attribute 'a1'
```
分析：
1. Class A实现了__get__方法，所以它是一个非数据描述器
2. 由于Class B里面设置的x属性是Class A的实例，所以在定义阶段就会实例化，把实例化的对象赋给x属性，所以会先执行A的__init__方法。
3. 访问实例b的x属性时，发现值是一个描述器，然后就会被描述器A的__get__方法捕获
4. __get__方法默认然会None，所以None对象没有a1属性，所以报属性错误
5. 在__get__方法中，return self就可以访问了  

那么self是什么，__get__方法的参数都是什么意思：
- `self`：对应A的实例(这里是属性x)
- `owner`：对应的是x属性的拥有者，也就是B类
- `instance`：它的值有两个
    - 当使用owner类直接调用时，`它是None`
    - 当使用owner类的实例调用是，是`实例本身`