# 1 函数的执行流程
函数的执行需要对函数进行压栈的，什么是压栈呢，简而言之就是在函数执行时在栈中创建栈帧存放需要变量以及指针的意思。具体涉及的知识非常多，这里就已一个Python脚本简单进行分析。
```python
def foo1(b, b1=3):
    print('call foo1', b, b1)

def foo2(c):
    foo3(c)
    print('call foo2', c)

def foo3(d):
    print('call foo3', d)

def main():
    print('call main')
    foo1(100, 101)
    foo2(20)
    print('main ending')

main()
```
当我们运行上面代码时，它的执行流程如下：
1. 全局栈帧中生成foo1、foo2、foo3、main函数对象
2. main函数调用
3. main中查找内建函数print压栈，将常量字符串压栈，调用函数，弹出栈顶
4. main中全局查找函数foo1压栈，将常量100、101压栈，调用函数foo1，创建栈帧。print函数压栈，字符串和变量b、b1压栈，调用函数，弹出栈顶，返回值。
5. main中全局查找foo2函数压栈，将常量200压栈，调用foo2，创建栈帧。foo3函数压栈，变量c引用压栈，调用foo3，创建栈帧。foo3完成print函数调用返回。foo2恢复调用，执行print语句后，返回值。main中foo2调用结束后弹出栈顶，main继续执行print函数调用，弹出栈顶，main函数返回

4、Python函数执行过程
    函数的执行流程
    压栈过程
    
    def outer():
        c = 100
        def inner():
            nonlocal c
            c += 200
            return c
        return inner

    a = outer()
    a()
    函数只有在执行的时候才会压栈，所以在outer执行时，会开辟栈空间压栈(c,inner)，执行完后，删除栈空间，但是由于outer返回了内部函数inner，但并没有执行，所以不会继续压栈，当执行a的时候，会重新压栈，而此时内部函数已经记住了外部自由变量
c，并且每次调用outer都会重新生成一个inner。    
    注意：这种情况叫做闭包，自由变量c会被当成内部函数inner的一个属性，被调用。
    PS：内存两大区域（栈，堆）  --> 垃圾回收，清理的是堆中的空间
    函数的调用就是压栈的过程，而变量的创建都是在堆中完成的。 栈中存储的都是堆中的内存地址，栈清空，并不会使堆中的对象被清除，只是指向已经被删除。
    （函数，变量都是再堆内创建的，函数调用需要压栈） 
    
5、递归函数

    # 循环版（循环不用压栈)
    def fib(n):
        a = 0 
        b = 1 
        for i in range(n-1):
            a,b = b,a+b
        return b 
      
    # 公式版本  
    def fib(n):
        if n < 3:
            return 1
        return fib(n-1) + fib(n-2)
    
    print(fib(3))
    # 公式版本之简洁版
    def fib(n):
        return 1 if n < 3 else fib(n-1) + fib(n-2)
        
    # 优化版（优化重复计算）
    def fib(n, a=0, b=1):
        a,b = b, a+b
        if n == 0:
            return b 
        return fib(n-1, a, b) 
    
    查看递归的层数：
    import sys
    sys.getrecursionlimit()

2019/1/16 匿名函数、Python生成器
1、匿名函数：
    lambda '参数列表不要括号'：'return语句'
    等于:
    def xxx(x):
        return x 
    a. 右边是函数体，不能出现等号。
    b. 函数体只能写一行，不能使用分号分隔多个语句。
    c. return语句，不写return关键字
   
    (lambda x,y: x + y)(4,5)
    (lambda x,y=10: x+y)(10)
    (lambda x,y=10: x+y)(x=10)
    (lambda x,y=10: x+y)(10,y=10)
    (lambda x,y=10,*args: x+y)(10,y=10)    
    (lambda x,y=10,*args,m,n,**kwargs: x+y)(10,y=10)  
    (lambda *args:(i for i in args)(1,2,3,4,5)
    (lambda *args:(i for i i in args))(*range(5))
    [x for x in (lambda *args: (i for i in args))(*range(5))]
    [ x for x in (lambda *args: map(lambda x:x+1,(i for i in args)))(*range(5))]

    d = defaultdict(lambda :0)  ==>  (lambda :0)()
   
2、Python生成器
    yield关键字，返回一个生成器对象
    yield关键字，和return关键字在生成器场景下，不能一起使用。
    
    def inc():
        def counter():
            c = 0
            while True:
                c += 1
                yield c 
        c = counter()
        
        def inner():
            return next(c)    ==> 闭包
           
        return inner 
        调用时注意：
            foo = inc()  
            foo() 
        不等于:
            inc()()   # 每次都会重复执行inc(),每次都会生成新的c，所以每次都时1
            
    等价于:
    def inc():
        def counter():
            c = 0
            while True:
                c += 1
                yield c 
        c = counter()
        
        return lambda : next(c) 

    错误版本:
    def inc():
        def counter():
            c = 0
            while True:
                c += 1
                yield c 
        c = counter()
        
        return next(c)    
        # 每次执行inc，c都会被重新生成，所以永远返回1 

    生成器版本fib
    def fib(n):
        x = 1
        y = 1
        for i in range(n-1):
            x,y = y,x+y 
            yield y 
        # yield y    
        # return y  

    coroutine 协程**
        生成器的高级用法
        
yield from 语法 （(python 3.3 新增)
    
    def fn():
        for i in range(10):
           yield i 
    等同于：---------
    def fn():
        yield from range(10)