# 1 魔术方法
　　在Python中以两个下划线开头和结尾的方法，比如：\_\_init\_\_、\_\_str\_\_、\_\_doc\_\_、\_\_new\_\_等，被称为"魔术方法"（Magic methods）。魔术方法在类或对象的某些事件出发后会自动执行，如果希望根据自己的程序定制自己特殊功能的类，那么就需要对这些方法进行重写。
> Python 将所有以 \_\_（两个下划线）开头和结尾的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 \_\_ 为前缀。
# 2 类的魔术方法
我们将不同类型的魔术方法进行归类，那么会分为以下几类。
## 2.1 基本的魔法方法和常用属性
|魔术方法|含义|
|-------|----|
\_\_new\_\_(cls[, ...])|1. \_\_new\_\_ 是在一个对象实例化的时候所调用的第一个方法<br>2. 它的第一个参数是这个类，其他的参数是用来直接传递给 \_\_init\_\_ 方法<br>3. \_\_new\_\_ 决定是否要使用该 \_\_init\_\_ 方法，因为 \_\_new\_\_ 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 \_\_new\_\_ 没有返回实例对象，则 \_\_init\_\_ 不会被调用<br>4. \_\_new\_\_ 主要是用于继承一个不可变的类型比如一个 tuple 或者 string
\_\_init\_\_(self[, ...])|构造器，当一个实例被创建的时候调用的初始化方法
\_\_del\_\_(self)|析构器，当一个实例被销毁的时候调用的方法
\_\_call\_\_(self[, args...])|允许一个类的实例像函数一样被调用：x(a, b) 调用 x.\_\_call\_\_(a, b)
\_\_len\_\_(self)|定义当被 len() 调用时的行为
\_\_repr\_\_(self)|定义当被 repr() 调用或者直接执行对象时的行为
\_\_str\_\_(self)|定义当被 str() 调用或者打印对象时的行为
\_\_bytes\_\_(self)|定义当被 bytes() 调用时的行为
\_\_hash\_\_(self)|定义当被 hash() 调用时的行为
\_\_bool\_\_(self)|定义当被 bool() 调用时的行为，应该返回 True 或 False
\_\_format\_\_(self, format_spec)|定义当被 format() 调用时的行为
\_\_name\_\_|类、函数、方法等的名字
\_\_module\_\_|类定义所在的模块名
\_\_class\_\_|对象或类所属的类
\_\_bases\_\_|类的基类元组，顺序为它们在基类列表中出现的顺序
\_\_doc\_\_|类、函数的文档字符串，如果没有定义则为None
\_\_mro\_\_|类的mro,class.mro()返回的结果保存在\_\_mro\_\_中
\_\_dict\_\_|类或实例的属性，可写的字典
## 2.2 有关属性
|魔术方法|含义|
|-------|----|
\_\_getattr\_\_(self, name)|定义当用户试图获取一个不存在的属性时的行为
\_\_getattribute\_\_(self, name)|定义当该类的属性被访问时的行为
\_\_setattr\_\_(self, name, value)|定义当一个属性被设置时的行为
\_\_delattr\_\_(self, name)|定义当一个属性被删除时的行为
\_\_dir\_\_(self)|定义当 dir() 被调用时的行为
\_\_get\_\_(self, instance, owner)|定义当描述符的值被取得时的行为
\_\_set\_\_(self, instance, value)|定义当描述符的值被改变时的行为
\_\_delete\_\_(self, instance)|定义当描述符的值被删除时的行为
## 2.3 比较操作符
|魔术方法|含义|
|-------|----|
\_\_lt\_\_(self, other)|定义小于号的行为：x < y 调用 x.\_\_lt\_\_(y)
\_\_le\_\_(self, other)|定义小于等于号的行为：x <= y 调用 x.\_\_le\_\_(y)
\_\_eq\_\_(self, other)|定义等于号的行为：x == y 调用 x.\_\_eq\_\_(y)
\_\_ne\_\_(self, other)|定义不等号的行为：x != y 调用 x.\_\_ne\_\_(y)
\_\_gt\_\_(self, other)|定义大于号的行为：x > y 调用 x.\_\_gt\_\_(y)
\_\_ge\_\_(self, other)|定义大于等于号的行为：x >= y 调用 x.\_\_ge\_\_(y)
## 2.4 算数运算符
|魔术方法|含义|
|-------|----|
\_\_add\_\_(self, other)|定义加法的行为：+
\_\_sub\_\_(self, other)|定义减法的行为：-
\_\_mul\_\_(self, other)|定义乘法的行为：*
\_\_truediv\_\_(self, other)|定义真除法的行为：/
\_\_floordiv\_\_(self, other)|定义整数除法的行为：//
\_\_mod\_\_(self, other)|定义取模算法的行为：%
\_\_divmod\_\_(self, other)|定义当被 divmod() 调用时的行为
\_\_pow\_\_(self, other[, modulo])|定义当被 power() 调用或 ** 运算时的行为
\_\_lshift\_\_(self, other)|定义按位左移位的行为：<<
\_\_rshift\_\_(self, other)|定义按位右移位的行为：>>
\_\_and\_\_(self, other)|定义按位与操作的行为：&
\_\_xor\_\_(self, other)|定义按位异或操作的行为：^
\_\_or\_\_(self, other)|定义按位或操作的行为：|
## 2.5 反运算
|魔术方法|含义|
|-------|----|
\_\_radd\_\_(self, other)|（与上方相同，当左操作数不支持相应的操作时被调用）
\_\_rsub\_\_(self, other)|（与上方相同，当左操作数不支持相应的操作时被调用）
\_\_rmul\_\_(self, other)|（与上方相同，当左操作数不支持相应的操作时被调用）
\_\_rtruediv\_\_(self, other)|（与上方相同，当左操作数不支持相应的操作时被调用）
\_\_rfloordiv\_\_(self, other)|（与上方相同，当左操作数不支持相应的操作时被调用）
\_\_rmod\_\_(self, other)|（与上方相同，当左操作数不支持相应的操作时被调用）
\_\_rdivmod\_\_(self, other)|（与上方相同，当左操作数不支持相应的操作时被调用）
\_\_rpow\_\_(self, other)|（与上方相同，当左操作数不支持相应的操作时被调用）
\_\_rlshift\_\_(self, other)|（与上方相同，当左操作数不支持相应的操作时被调用）
\_\_rrshift\_\_(self, other)|（与上方相同，当左操作数不支持相应的操作时被调用）
\_\_rand\_\_(self, other)|（与上方相同，当左操作数不支持相应的操作时被调用）
\_\_rxor\_\_(self, other)|（与上方相同，当左操作数不支持相应的操作时被调用）
\_\_ror\_\_(self, other)|（与上方相同，当左操作数不支持相应的操作时被调用）
## 2.6 增量赋值运算
|魔术方法|含义|
|-------|----|
\_\_iadd\_\_(self, other)|定义赋值加法的行为：+=
\_\_isub\_\_(self, other)|定义赋值减法的行为：-=
\_\_imul\_\_(self, other)|定义赋值乘法的行为：*=
\_\_itruediv\_\_(self, other)|定义赋值真除法的行为：/=
\_\_ifloordiv\_\_(self, other)|定义赋值整数除法的行为：//=
\_\_imod\_\_(self, other)|定义赋值取模算法的行为：%=
\_\_ipow\_\_(self, other[, modulo])|定义赋值幂运算的行为：**=
\_\_ilshift\_\_(self, other)|定义赋值按位左移位的行为：<<=
\_\_irshift\_\_(self, other)|定义赋值按位右移位的行为：>>=
\_\_iand\_\_(self, other)|定义赋值按位与操作的行为：&=
\_\_ixor\_\_(self, other)|定义赋值按位异或操作的行为：^=
\_\_ior\_\_(self, other)|定义赋值按位或操作的行为：|=
## 2.7 一元操作符
|魔术方法|含义|
|-------|----|
\_\_pos\_\_(self)|定义正号的行为：+x
\_\_neg\_\_(self)|定义负号的行为：-x
\_\_abs\_\_(self)|定义当被 abs() 调用时的行为
\_\_invert\_\_(self)|定义按位求反的行为：~x
## 2.8 类型转换
|魔术方法|含义|
|-------|----|
\_\_complex\_\_(self)|定义当被 complex() 调用时的行为（需要返回恰当的值）
\_\_int\_\_(self)|定义当被 int() 调用时的行为（需要返回恰当的值）
\_\_float\_\_(self)|定义当被 float() 调用时的行为（需要返回恰当的值）
\_\_round\_\_(self[, n])|定义当被 round() 调用时的行为（需要返回恰当的值）
\_\_index\_\_(self)|1. 当对象是被应用在切片表达式中时，实现整形强制转换<br>2. 如果你定义了一个可能在切片时用到的定制的数值型,你应该定义 \_\_index\_\_<br>3. 如果 \_\_index\_\_ 被定义，则 \_\_int\_\_ 也需要被定义，且返回相同的值
## 2.9 上下文管理（with 语句）
|魔术方法|含义|
|-------|----|
\_\_enter\_\_(self)|1. 定义当使用 with 语句时的初始化行为<br>2. \_\_enter\_\_ 的返回值被 with 语句的目标或者 as 后的名字绑定
\_\_exit\_\_(self, exc_type, exc_value, traceback)|1. 定义当一个代码块被执行或者终止后上下文管理器应该做什么<br>2. 一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作
## 2.10 容器类型
|魔术方法|含义|
|-------|----|
\_\_len\_\_(self)|定义当被 len() 调用时的行为（返回容器中元素的个数）
\_\_getitem\_\_(self, key)|定义获取容器中指定元素的行为，相当于 self[key]
\_\_setitem\_\_(self, key, value)|定义设置容器中指定元素的行为，相当于 self[key] = value
\_\_delitem\_\_(self, key)|定义删除容器中指定元素的行为，相当于 del self[key]
\_\_iter\_\_(self)|定义当迭代容器中的元素的行为
\_\_reversed\_\_(self)|定义当被 reversed() 调用时的行为
\_\_contains\_\_(self, item)|定义当使用成员测试运算符（in 或 not in）时的行为
# 3 常用方法
上面基本上是Python中类的所有魔术方法了，下面针对一些重要的常用的方法进行说明。
## 3.1 查看属性
方法|意义|
---|----|
__dir__()|返回类或者对象的所有成员的名称列表<br>dir()函数操作实例调用的就是__dir__()|  

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当dir(obj)时，obj的__dir__()方法被调用，如果当前实例不存在该方法，则按照mro开始查找，如果父类都没有定义，那么最终会找到object.__dir__()方法，该方法会最大程度的收集属性信息。
```python
class A:
    def __dir__(self):
        return 'ab'

class B(A):
    pass

print(dir(A)) # ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']

print(dir(B())) # ['a', 'b']
```
dir(obj)对于不同类型的对象obj具有不同的行为：
1. 如果对象是模块对象，返回的列表包含模块的属性和变量名
2. 如果对象是类型或者说是类对象，返回的列表包含类的属性名，及它的祖先类的属性名
3. 如果是类的实例
    - 有__dir__方法，则返回__dir__方法的返回值(`必须可迭代`)
    - 没有__dir__方法，则尽可能的收集实例的属性名、类的属性和祖先类的属性名，`组成列表返回`。
4. 如果dir没有参数，返回列表包含的内容也不同。
    - 在模块中，返回模块的属性和变量名(和`globals()`结果相同)
    - 在函数中，返回本地作用域的变量名(和`locals()`结果相同)
    - 在方法中，返回本地作用域的变量名(和`locals()`结果相同)
> locals()运行在全局时，结果和globals()相同
## 3.2 实例化
|方法|含义|
----|-----|
__new__|实例化一个对象<br>该方法需要返回一个值，如果该值不是cls的实现，则不会调用__init__<br>该方法永远都是静态方法 
```python
class A:
    def __new__(cls, *args, **kwargs):
        print(cls)  # <class '__main__.A'>
        print(args)  # ('daxin',)
        print(kwargs)  # {'age': 20}

    def __init__(self, name, age):
        self.name = name
        self.age = age


daxin = A('daxin', age=20)
print(daxin.name)  # 'NoneType' object has no attribute 'name'
```

分析：
1. 实例化时执行__new__函数，进行实例化操作。
2. 前面学的__init__函数，我们知道它必须返回None，所以构建好的实例应该是在__new__函数中返回的。
3. 顺序：__new__构建实例，调用__init__函数进行初始化，然后由__new__函数返回实例。
4. 我们不知道实例到底是如何实例化的，所以这里可以使用super函数
```python
class A(object):
    def __new__(cls, *args, **kwargs):
        print(cls)  # <class '__main__.A'>
        print(args)  # ('daxin',)
        print(kwargs)  # {'age': 20}
        return super().__new__(cls)    # 只需要传递cls即可

    def __init__(self, name, age):
        self.name = name
        self.age = age


daxin = A('daxin', 20)
print(daxin)
print(daxin.name)  # 'NoneType' object has no attribute 'name'
print(daxin.age)  # 'NoneType' object has no attribute 'name'
```
注意：__new__方法很少用，即使创建了该方法，也会使用return super().__new__(cls)，调用基类objct的__new__方法来创建实例并返回。除非使用元类编程。
## 3.3 hash相关
|方法|意义|
-----|---|
__hash__|内建函数hash()调用的返回值，返回一个整数。如果定义这个方法该类的实例就可hash。
__eq__|对应==操作符，判断2个对象是否相等，返回bool值
```python
class A:
    def __hash__(self):
        return 123   # 返回值必须是数字

a = A()
print(hash(a))  # 123
```
一般来说提供__hash__方法是为了作为set或者dict的key的。但是key是不重复的，所以怎么去重呢？
### 3.3.1 hash相同能否去重
前面我们知道，set类型是不允许有重复数据的，那么它是怎么去重的呢？我们说每个元素的hash值都不相同，是通过hash值来去重的吗？
```python
class A:
    def __init__(self, name):
        self.name = name

    def __hash__(self):
        return 123  # 返回值必须是数字

    def __repr__(self):  # 为了打印方便，这里使用repr定义类型输出格式
        return '<{}>'.format(self.name)

a = A('daxin')
b = A('daxin')
s = {a,b}
print(s)   # {<daxin>, <daxin>}
```
### 3.3.2 比较内容是否相同
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hash值相同的情况下，从结果看并没有去重。所以，去重，并不是只看hash值，还需要使用__eq__来判断2个对象是否相等。hash值相等，只是说明hash冲突，并不能说明两个对象是相等的。判断内容是否相等一般使用的是 == , 使用 == 进行比较时，就会触发对象的__eq__方法。所以我们来测试一下。
```python
class A:
    def __init__(self, name):
        self.name = name

    def __hash__(self):
        return 123  # 返回值必须是数字

    def __repr__(self):  # 为了打印方便，这里使用repr定义类型输出格式
        return '<{} {}>'.format(self.name, id(self))

    def __eq__(self, other):  # self是实例本身，other就是等式右边的对象
        return True   # 衡返回True，就表示只要进行比较就相等

a = A('daxin')
b = A('daxin')
print(a,b)  # <daxin 2621275933832> <daxin 2621275933888>
print({a, b})  # {<daxin 2621275933832>}
```
所以：去重的条件，首先判断的是hash值，hash值相同的情况下，判断内容是否相等，确认是否是同一个元素。所以__eq__方法就很重要了。
```python
def __eq__(self, other):
    return id(self) == id(other)
```
注意：
1. __eq__：返回值必须是一个bool类型。
2. 只写__eq__方法，那么当前实例就无法可hash了，所以就无法去重了。
3. 如果要去重，还需要配合__hash__方法，才可以变为可hash对象。  
> 判断是否是不可hash对象，可以使用：isinstance(a, collection.Hashable)，False表示不可hash。

想一下为什么list对象不可hash？ 来看一下List的原码
```python
...
    __hash__ = None
...
```
在list内部，它把__hash__属性置为None了，学到一招，所以如果一个对象，不能被hash，那就把它置为None把。
### 3.3.3 坐标轴小例子
设计二维坐标类Ponit, 使其成为可hash类型，并比较2个坐标的实例，是否相等？
```python
class Point:

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __hash__(self):
        return hash(self.x) + hash(self.y)    # 使用+拼接有很大几率相同，这里可以使用 return hash((self.x, self.y))

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y
        # 如果id相同，那么就不需要再比较属性了，因为肯定是同一个数据
        # return self is other or (self.x == other.x and self.y == other.y)

    def __repr__(self):
        return '{} {} {}'.format(self.x, self.y, id(self))


a = Point(3, 4)
b = Point(3, '4')
print(set([a, b]))
```
## 3.4 bool类型
|方法|意义|
----|-----|
__bool__|内建函数bool(),或者被当作逻辑表达式时，调用这个__bool__函数的返回值。<br>如果没有定义__bool__函数，那么就会寻找__len__返回长度，非0为真。<br>如果__len__()也没有定义，那么所有实例都返回真

即：使用bool时，先判断__bool__，然后再判断__len__，否则True
```python
class A:

    def __bool__(self):
        return False

print(bool(A()))   # False


class A:

    def __len__(self):   # 只有len
        return 1   
    
print(bool(A()))   # True
```
__len__的返回值必须为大于0的整数。