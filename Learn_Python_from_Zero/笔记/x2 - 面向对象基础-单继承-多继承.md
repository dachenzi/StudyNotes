# 1 类的继承
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继承是面向对象的重要特性之一，是相对两个类而言的父子关系，子类继承了父类的所有的属性和方法，继承最大的好处是实现了代码的重用，可以重用已经存在的数据和行为，减少代码的重复编写。
# 2 不同版本的类
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Python2.2之前，类是没有共同的祖先的，之后，引入了object类，它是所有类的共同祖先类。Python2中为了兼容，分为古典类(旧式类)和新式类。而在Python 3中全部都为新式类，新式类都是继承object类的，并且可以使用super函数(后面会说)。下面是Python2.x中的代码
```python
class A:
    pass

class B(object):
    pass

>>> dir(A)  # 查看类的__dict__
['__doc__', '__module__']
>>> dir(B)
['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']
```
在Python2.x中 A和B是不同的两个类。A没有继承，被称为古典类，B继承自object，被称为新式类。不止少了很多方法，连实例对象的属性也是不太相同的。Python 3中的代码如下
```python
class A:
    pass

class B(object):
    pass
 
>>> dir(A)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']
>>> dir(B)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']
>>> 
```
在Python 3中，都为新式类，所以A和A(object)是两个结果相同的不同写法而已 `class A:pass  ==  class A(object):pass`。
> 更多的区别这里就不在详述，Python 3是未来，忘记旧式类吧。
# 3 基本概念
Python在类名后使用一对括号来表示继承关系，括号中的类即为父类。先来看看不用继承的例子：
```python
class Animal:

    def shout(self):
        print('{} shout'.format(self.__class__.__name__))

class Cat:
    def shout(self):
        print('{} shout'.format(self.__class__.__name__))

class Dog:
    def shout(self):
        print('{} shout'.format(self.__class__.__name__))

a = Animal()
c = Cat()
d = Dog()

a.shout()
c.shout()
d.shout()
```
从上面例子来看，虽然猫狗动物都可以叫，但是却分别实现了叫这个动作，那么下一步使用继承来优化
```python
class Animal:

    def shout(self):
        print('{} shout'.format(self.__class__.__name__))

class Cat(Animal): pass
class Dog(Animal): pass

a = Animal()
c = Cat()
d = Dog()

a.shout()
c.shout()
d.shout()
```
通过继承，猫类、狗类就不用写代码，直接继承了父类Animal类的叫方法了。所以，在上面的例子中：
- 父类：Animal是Cat和Dog的父类，也成为基类、超类
- 子类：Cat和Dog是Animal的子类，也成为派生类
# 4 特殊属性和方法
和继承相关的常用特殊属性和方法如下：
|特殊属性和方法|含义|示例|
|------|---|---|
`__base__`|类的基类|
`__bases__`|类的基类们(元组)|
`__mro__`|方法解析顺序(基类们的元组)|
`mro()`|方法解析顺序(基类们的列表)|int.mro()
`__subclasses__()`|类的子类列表|int.__subclasses__()int.__subclasses__()
# 5 继承中的访问控制
通过一个例子来看继承中的访问控制
```python
class Animal:
    __COUNT = 100   # _Animal__COUNT = 100
    HEIGHT = 0

    def __init__(self, age,weight,height):
        self.__COUNT += 1  # self._Animal_COUNT = self._Animal_COUNT + 1
        self.age = age
        self.__weight = weight  # self._Animal__weight = weight
        self.HEIGHT = height

    def eat(self):
        print('{} eat'.format(self.__class__.__name__))

    def __getweight(self):    # def _Animal__getweight(self):
        print(self.__weight)  #     print(self._Animal__weight)

    @classmethod
    def showcount1(cls):
        print(cls)
        print(cls.__dict__)
        print(cls.__COUNT)    # print(cls._Animal__COUNT)

    @classmethod
    def __showcount2(cls):    # def _Animal__showcount2(cls):
        print(cls.__COUNT)    #     print(cls._Animal__COUNT)

    def showcount3(self):
        print(self.__COUNT)   # print(self._Animal__COUNT)

class Cat(Animal):
    NAME = 'CAT'
    __COUNT = 200   # _Cat__Count = 200

c = Cat(3,5,15)
c.eat()          # 1 
print(c.HEIGHT)  # 2 
print(c.__COUNT) # 3
print('c:',c.__dict__)
print('cat:',Cat.__dict__)
print('Animal:',Animal.__dict__)
c.showcount1()   # 4
c.showcount2()   # 5
c.showcount3()   # 6
print(c.NAME)    # 7 
```