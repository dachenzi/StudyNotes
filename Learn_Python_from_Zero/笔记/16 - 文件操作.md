# Python文件操作
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;读写文件是最常见的IO操作(一般说IO操作，指的是文件IO，如果是网络，一般都会直接说网络IO)，在磁盘上读写文件的功能都是由操作系统提供的，操作系统不允许普通的程序直接操作磁盘(大部分程序都需要间接的通过操作系统来完成对硬件的操作)，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。在操作系统中，文件常用的操作有：
|功能|介绍|
|--|--|
open|打开
read|读取
write|写
close|关闭
readline|行读取
readlines|多行读取
seek|文件指针操作
tell|指针操作  
# 1 open函数介绍
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在python中，我们使用open函数来打开一个文件，然后返回一个文件对象(流对象)和文件描述符。打开文件失败，则返回异常。
> 第三方模块codecs包中提供的open函数，具备内置函数open的所有功能，并且在内部它对目标文件进行了编码的与判断处理，当你不知道目标文件的编码类型时，使用codecs.open来说更可靠。
# 2 打开操作
想要读取文件，那么就需要先行打开文件。下面来看一下open函数的用法
```python
open(['file', "mode='r'", 'buffering=-1', 'encoding=None', 'errors=None', 'newline=None', 'closefd=True', 'opener=None'],)
```
- `file`：要打开的文件名(默认为当前路径，否则要指定绝对路径)。
- `mode`：表示打开文件的格式。
- `buffering`: 设置缓冲区的大小(二进制模式和文本模式不同)
- `encoding`：打开文件的编码格式(文本模式)
- `errors`: 转码错误时是否提示异常
- `newline`: 文本模式中对新行的处理方式
- `closefd`: 删除描述符时，文件对象是否释放
> Python 2.x中包含file和open两个操作文件的函数，Python 3.x 中只有open，操作方法相同 `f = file('/etc/passwd','r') `
# 2.1 mode模式
文件打开的方式有如下几种：
|描述字符|意义|备注|
|----|----|---|
|r|只读打开|文件的默认打开方式，文件不存在会报异常
w|只写打开|文件不存在会创建，存在的话，会覆盖源文件（非追加）
x|创建并只写一个新文件|文件已存在则报错
a|只追加写模式|在文件末尾追加，文件不存在，新建并追加
b|二进制模式|`字节流`，将文件就按照字节理解，与字符编码无关。二进制模式操作时，字节操作使用bytes类型
t|文本模式|`字符流`，将文件的字节按照某种字符编码理解，按照字符操作，缺省模式
+|读写打开一个文件|给原来只读、只写方式打开提供缺失的读或者写能力
> 默认使用文本只读模式打开,特殊文件需要用文本模式传输的话，建议使用b　  

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`+符`，为r、w、a、x提供缺失的读或者写的功能，但是，获取文件对象依旧按照r、w、a、x自己的特征。但+不能单独使用，可以认为它是为前面的模式字符做的增强功能。
|描述字符|意义|
|---|---|
r+|读模式附加写功能
w+|写模式附加读功能
a+|追加写模式附加读功能
x+|打开一个新文件可读可写
> 以上为文本模式，二进制模式时只需要添加b即可.即r+b,或者rb+都可



　　我们把这个 f 成为文件句柄（用来标识一个文件的内存对象），包含文件名，字符集，大小，硬盘上的起始位置等等。
　　f在这里就变成了一个文件迭代器，我们可以通过使用for line in f ,去循环的读取文件的每一行内容


文件对象方法
　　文件对象的内置方法有很多种，如下所示：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
fd.closed()：判断文件是否被关闭，若被打开提示False，没有的话提示True
fd.flush()：把修改的内容，强制刷新到文件中去
fd.isatty：判断是否是一个终端文件
fd.mode：查看文件的打开模式
fd.name：查看文件的名称
fd.next：迭代的方法，和readline很像，区别是，next读到末尾会报错，readline会继续返回空
fd.read：一次性读取所有内容，以字符串的方式存取
fd.readable():判断文件是否可读
fd.readlines：一次性读取所有内容，以列表的方式存取（适合操作小文件）
fd.readline()：每次读取一行内容
fd.seek(0)：调整文件读取的指针位置
fd.seekable()：判断文件是否可以调整指针位置（tty，磁盘等文件是不能被seek的），可以被seek则返回真，否则返回假 --Python3.x
fd.tell()：查询文件目前读取位置（以字符为单位）
fd.truncate()：截取文件，从开头开始截取，不指定指针位置的话，那么会清空文件
fd.write：把一个字符串写入到文件中去
fd.writelines()：把字符串列表写入文件中
fd.xreadlines()：读一行打印一行，针对大文件非常适用 -----> Python 2.x 中适用，3.x中已经取消
fd.encoding:查看文件的编码
fd.writeable()：判断文件是否可以写
fd.fileno()： 返回文件在操作系统上的文件描述符（默认会打开三个：0表示 stdin、1表示 stdout，2表示stderr）
fd.name：文件名称 
练习
　　for 循环遍历文件，打印文件的每一行
1
2
3
4
5
6
#!/usr/bin/env python
fd = open('/tmp/hello.txt')
for line in fd:
print line,
  
注意：这里for line in fd，其实可以从fd.readlines()中读取，但是如果文件很大，那么就会一次性读取到内存中，非常占内存，而这里fd存储的是对象，只有我们读取一行，它才会把这行读取到内存中，建议使用这种方法。
　　while循环遍历文件：
1
2
3
4
5
6
7
8
#!/usr/bin/env python
fd = open('/tmp/hello.txt')
while True:
line = fd.readline()
if not line:
break
print line,
fd.close()
使用with
　　如果不想每次打开文件都关闭，可以使用with关键字，2.6以上版本支持with读取 with open('/tmp/hello.txt') as fd: 然后所有打开文件的操作都需要缩进，包含在with下才，这样不需要明确的指定close，当新的代码没有缩进的时候，文件会自动关闭。
1
2
3
4
5
6
with open('/tmp/hello.txt') as fd:
    while True:
        line = fd.readline()
            if not line:
                break
            print line,